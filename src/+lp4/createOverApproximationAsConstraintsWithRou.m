function constraints = createOverApproximationAsConstraintsWithRou(p, pPartition, c, cPartition, w, rou)
%createOverApproximationAsConstraintsWithRou Create an over approximation for W = P * C.

if ~isa(p, 'sym') || ~isa(c, 'sym') || ~isa(w, 'sym') || ~isa(rou, 'sym')
    error('p or c or w is not a symbolic variable.');
end
if pPartition.boundLow >= pPartition.boundHigh || cPartition.boundLow >= cPartition.boundHigh
    error('');
end

a1 = pPartition.boundLow;
a2 = pPartition.boundHigh;
b1 = cPartition.boundLow;
b2 = cPartition.boundHigh;
minW = min([a1*b1, a1*b2, a2*b1, a2*b2]);
maxW = max([a1*b1, a1*b2, a2*b1, a2*b2]);
constraints =...
    [-w + b2*p + a2*c - a2*b2 - rou,...
    w - b2*p - a2*c + a2*b2 - (a2-a1)*(b2-b1) - rou,...
    -w + minW - rou,...
    w - maxW - rou];

% A sample for over approximation for p, c in range [-0.5, 0.5]
%     constraints = [-w + 0.5*p + 0.5*c - 0.25 - rou,...
%         w - 0.5*p - 0.5*c - 0.25 - rou,...
%        -w - 0.5*p- 0.5*c - 0.25- rou...
%         w + 0.5*p + 0.5*c-0.25- rou...
%        -w - 0.5*p + 0.5*c - 0.25- rou...
%        w + 0.5*p - 0.5*c-0.25- rou...
%        w - 0.5*p + 0.5*c-0.25- rou...
%        -w + 0.5*p - 0.5*c - 0.25- rou...
%         w - 0.25 - rou,...
%         -w - 0.25 - rou];

% if p and c are both of [-x, x]
% if pPartition.boundLow == -pPartition.boundHigh && pPartition.boundLow == cPartition.boundLow && cPartition.boundLow == -cPartition.boundHigh
%     v = pPartition.boundHigh;
%     v2 = v * v;
%     constraints =...
%         [-w + v*p + v*c - v2 - rou,...
%         w - v*p - v*c - v2 - rou ,...
%         -w - v*p - v*c - v2 - rou,...
%         w + v*p + v*c - v2 - rou ,...
%         -w - v*p + v*c - v2 - rou,...
%         w + v*p - v*c - v2 - rou ,...
%         w - v*p + v*c - v2 - rou,...
%         -w + v*p - v*c - v2 - rou ,...
%         w - v2 - rou,...
%         -w - v2 - rou];
% else
%     % error('');
% end

end

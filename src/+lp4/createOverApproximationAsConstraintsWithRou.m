function constraints = createOverApproximationAsConstraintsWithRou(p, pPartition, c, cPartition, w, rou)
%CREATEOVERAPPROXIMATION Create an over approximation for W = P * C.

if ~isa(p, 'sym') || ~isa(c, 'sym') || ~isa(w, 'sym') || ~isa(rou, 'sym')
    error('p or c or w is not a symbolic variable.');
end
if pPartition.boundLow >= pPartition.boundHigh || cPartition.boundLow >= cPartition.boundHigh
    error('');
end

% A sample for over approximation for p, c in range [-0.5, 0.5]
%     constraints = [-w + 0.5*p + 0.5*c - 0.25 - rou,...
%         w - 0.5*p - 0.5*c - 0.25 - rou,...
%        -w - 0.5*p- 0.5*c - 0.25- rou...
%         w + 0.5*p + 0.5*c-0.25- rou...
%        -w - 0.5*p + 0.5*c - 0.25- rou...
%        w + 0.5*p - 0.5*c-0.25- rou...
%        w - 0.5*p + 0.5*c-0.25- rou...
%        -w + 0.5*p - 0.5*c - 0.25- rou...
%         w - 0.25 - rou,...
%         -w - 0.25 - rou];

% if p and c are both of [-x, x]
if pPartition.boundLow == -pPartition.boundHigh && pPartition.boundLow == cPartition.boundLow && cPartition.boundLow == -cPartition.boundHigh
    v = pPartition.boundHigh;
    v2 = v * v;
    constraints =...
        [-w + v*p + v*p - v2 - rou,...
        w - v*p - v*c - v2 - rou ,...
        -w - v*p - v*p - v2 - rou,...
        w + v*p + v*c - v2 - rou ,...
        -w - v*p + v*p - v2 - rou,...
        w + v*p - v*c - v2 - rou ,...
        w - v*p + v*p - v2 - rou,...
        -w + v*p - v*c - v2 - rou ,...
        w - 1 - rou,...
        -w - 1 - rou];
else
    error('');
end

end
